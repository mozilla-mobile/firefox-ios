#!/usr/bin/awk -f
#
# This AWK script scans the opcodes.h file (which is itself generated by
# another awk script) and uses the information gleaned to create the
# opcodes.c source file.
#
# Opcodes.c contains strings which are the symbolic names for the various
# opcodes used by the VDBE.  These strings are used when disassembling a
# VDBE program during tracing or as a result of the EXPLAIN keyword.
#
BEGIN {
  print "/* Automatically generated.  Do not edit */"
  print "/* See the mkopcodec.awk script for details. */"
  printf "#if !defined(SQLITE_OMIT_EXPLAIN)"
  printf    " || defined(VDBE_PROFILE)"
  print     " || defined(SQLITE_DEBUG)"
  print "#if defined(SQLITE_ENABLE_EXPLAIN_COMMENTS) || defined(SQLITE_DEBUG)"
  print "# define OpHelp(X) \"\\0\" X"
  print "#else"
  print "# define OpHelp(X)"
  print "#endif"
  print "const char *sqlite3OpcodeName(int i){"
  print " static const char *const azName[] = { \"?\","
  mx = 0
}
/^.define OP_/ {
  sub("OP_","",$2)
  i = $3+0
  label[i] = $2
  if( mx<i ) mx = i
  for(j=5; j<NF; j++) if( $j=="synopsis:" ) break
  if( j<NF ){
    j++
    x = $j
    for(j=j+1; j<NF; j++) x = x " " $j
    synopsis[i] = x
  }else{
    synopsis[i] = ""
  }
}
END {
  for(i=1; i<=mx; i++){
    printf "     /* %3d */ %-18s OpHelp(\"%s\"),\n", i, \
        "\"" label[i] "\"", synopsis[i]
  }
  print "  };"
  print "  return azName[i];"
  print "}"
  print "#endif"
}
