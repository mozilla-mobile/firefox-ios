# 2008 June 21
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#***********************************************************************
#

set testdir [file dirname $argv0]
source $testdir/tester.tcl
db close

#-------------------------------------------------------------------------
# test_suite NAME OPTIONS
#
# where available options are:  
#
#       -description TITLE                  (default "")
#       -initialize  SCRIPT                 (default "")
#       -shutdown    SCRIPT                 (default "")
#       -presql      SQL                    (default "")
#       -files       LIST-OF-FILES          (default $::ALLTESTS)
#       -prefix      NAME                   (default "$::NAME.")
#       -dbconfig    SCRIPT                 (default "")
#
proc test_suite {name args} {

  set default(-shutdown)    ""
  set default(-initialize)  ""
  set default(-presql)      ""
  set default(-description) "no description supplied (fixme)"
  set default(-files)       ""
  set default(-prefix)      "${name}."
  set default(-dbconfig)    ""

  array set options [array get default]
  if {[llength $args]%2} {
    error "uneven number of options/switches passed to test_suite"
  }
  foreach {k v} $args {
    set o [array names options ${k}*]
    if {[llength $o]>1}  { error "ambiguous option: $k" }
    if {[llength $o]==0} { error "unknown option: $k" }
    set options([lindex $o 0]) $v
  }

  set     ::testspec($name) [array get options]
  lappend ::testsuitelist $name
}

#-------------------------------------------------------------------------
# test_set ARGS...
#
proc test_set {args} {
  set isExclude 0
  foreach a $args {
    if {[string match -* $a]} {
      switch -- $a {
        -include { set isExclude 0 }
        -exclude { set isExclude 1 }
        default {
          error "Unknown switch: $a"
        }
      }
    } elseif {$isExclude == 0} {
      foreach f $a { set t($f) 1 }
    } else {
      foreach f $a { array unset t $f }
      foreach f $a { array unset t */$f }
    }
  }

  return [array names t]
}

#-------------------------------------------------------------------------
# Set up the following global list variables containing the names of 
# various test scripts:
#
#   $alltests
#   $allquicktests
#
set alltests [list]
foreach f [glob $testdir/*.test] { lappend alltests [file tail $f] }
foreach f [glob -nocomplain $testdir/../ext/rtree/*.test] { 
  lappend alltests $f 
}

if {$::tcl_platform(platform)!="unix"} {
  set alltests [test_set $alltests -exclude crash.test crash2.test]
}
set alltests [test_set $alltests -exclude {
  all.test        async.test         quick.test  veryquick.test
  memleak.test    permutations.test  soak.test   fts3.test
  mallocAll.test  rtree.test         full.test
}]

set allquicktests [test_set $alltests -exclude {
  async2.test async3.test backup_ioerr.test corrupt.test
  corruptC.test crash.test crash2.test crash3.test crash4.test crash5.test
  crash6.test crash7.test delete3.test e_fts3.test fts3rnd.test
  fkey_malloc.test fuzz.test fuzz3.test fuzz_malloc.test in2.test loadext.test
  misc7.test mutex2.test notify2.test onefile.test pagerfault2.test 
  savepoint4.test savepoint6.test select9.test 
  speed1.test speed1p.test speed2.test speed3.test speed4.test 
  speed4p.test sqllimits1.test tkt2686.test thread001.test thread002.test
  thread003.test thread004.test thread005.test trans2.test vacuum3.test 
  incrvacuum_ioerr.test autovacuum_crash.test btree8.test shared_err.test
  vtab_err.test walslow.test walcrash.test walcrash3.test
  walthread.test rtree3.test indexfault.test securedel2.test
  sort3.test sort4.test fts4growth.test fts4growth2.test
  bigsort.test
}]
if {[info exists ::env(QUICKTEST_INCLUDE)]} {
  set allquicktests [concat $allquicktests $::env(QUICKTEST_INCLUDE)]
}
if {[info exists ::env(QUICKTEST_OMIT)]} {
  foreach x [split $::env(QUICKTEST_OMIT) ,] {
    regsub -all \\y$x\\y $allquicktests {} allquicktests
  }
}

# If the TEST_FAILURE environment variable is set, it means that we what to
# deliberately provoke test failures in order to test the test infrastructure.
# Only the main.test module is needed for this.
#
if {[info exists ::env(TEST_FAILURE)]} {
  set allquicktests main.test
}

#############################################################################
# Start of tests
#

#-------------------------------------------------------------------------
# Define the generic test suites:
#
#   veryquick
#   quick
#   full
#
lappend ::testsuitelist xxx

test_suite "veryquick" -prefix "" -description {
  "Very" quick test suite. Runs in less than 5 minutes on a workstation. 
  This test suite is the same as the "quick" tests, except that some files
  that test malloc and IO errors are omitted.
} -files [
  test_set $allquicktests -exclude *malloc* *ioerr* *fault*
]

test_suite "mmap" -prefix "mm-" -description {
  Similar to veryquick. Except with memory mapping enabled.
} -presql {
  pragma mmap_size = 268435456;
} -files [
  test_set $allquicktests -exclude *malloc* *ioerr* *fault* -include malloc.test
]

test_suite "valgrind" -prefix "" -description {
  Run the "veryquick" test suite with a couple of multi-process tests (that
  fail under valgrind) omitted.
} -files [
  test_set $allquicktests -exclude *malloc* *ioerr* *fault* wal.test \
              shell*.test crash8.test atof1.test selectG.test \
              tkt-fc62af4523.test
] -initialize {
  set ::G(valgrind) 1
} -shutdown {
  unset -nocomplain ::G(valgrind)
}

test_suite "valgrind-nolookaside" -prefix "" -description {
  Run the "veryquick" test suite with a couple of multi-process tests (that
  fail under valgrind) omitted.
} -files [
  test_set $allquicktests -exclude *malloc* *ioerr* *fault* wal.test atof1.test
] -initialize {
  set ::G(valgrind) 1
  catch {db close}
  sqlite3_shutdown
  sqlite3_config_lookaside 0 0
  sqlite3_initialize
  autoinstall_test_functions
} -shutdown {
  catch {db close}
  sqlite3_shutdown
  sqlite3_config_lookaside 100 500
  sqlite3_initialize
  autoinstall_test_functions
  unset -nocomplain ::G(valgrind)
}


test_suite "quick" -prefix "" -description {
  Quick test suite. Runs in around 10 minutes on a workstation.
} -files [
  test_set $allquicktests
]

test_suite "full" -prefix "" -description {
  Full test suite. Takes a long time.
} -files [ 
  test_set $alltests 
] -initialize {
  unset -nocomplain ::G(isquick)
}

test_suite "threads" -prefix "" -description {
  All multi-threaded tests.
} -files {
  notify2.test   thread001.test thread002.test thread003.test 
  thread004.test thread005.test walthread.test
}

test_suite "fts3" -prefix "" -description {
  All FTS3 tests except fts3rnd.test.
} -files {
  fts3aa.test fts3ab.test fts3ac.test fts3ad.test fts3ae.test
  fts3af.test fts3ag.test fts3ah.test fts3ai.test fts3aj.test
  fts3ak.test fts3al.test fts3am.test fts3an.test fts3ao.test
  fts3atoken.test fts3b.test fts3c.test fts3cov.test fts3d.test
  fts3defer.test fts3defer2.test fts3e.test fts3expr.test fts3expr2.test 
  fts3expr3.test
  fts3near.test fts3query.test fts3shared.test fts3snippet.test 
  fts3sort.test
  fts3fault.test fts3malloc.test fts3matchinfo.test
  fts3aux1.test fts3comp1.test fts3auto.test
  fts4aa.test fts4content.test
  fts3conf.test fts3prefix.test fts3fault2.test fts3corrupt.test
  fts3corrupt2.test fts3first.test fts4langid.test fts4merge.test
  fts4check.test fts4unicode.test fts4noti.test
  fts3varint.test
  fts4growth.test fts4growth2.test
}

test_suite "nofaultsim" -prefix "" -description {
  "Very" quick test suite. Runs in less than 5 minutes on a workstation. 
  This test suite is the same as the "quick" tests, except that some files
  that test malloc and IO errors are omitted.
} -files [
  test_set $allquicktests -exclude *malloc* *ioerr* *fault*
] -initialize {
  catch {db close}
  sqlite3_shutdown
  install_malloc_faultsim 0
  sqlite3_initialize
  autoinstall_test_functions
} -shutdown {
  unset -nocomplain ::G(valgrind)
}

test_suite "queryplanner" -prefix "" -description {
  Tests of the query planner and query optimizer
} -files {
  alter2.test alter3.test alter4.test alter.test analyze3.test
  analyze4.test analyze5.test analyze6.test analyze7.test analyze8.test
  analyze.test attach2.test attach3.test attach4.test
  attach.test autoinc.test autoindex1.test between.test cast.test
  check.test closure01.test coalesce.test collate1.test collate2.test
  collate3.test collate4.test collate5.test collate6.test collate7.test
  collate8.test collate9.test collateA.test colmeta.test colname.test
  conflict.test count.test coveridxscan.test createtab.test cse.test
  date.test dbstatus2.test dbstatus.test default.test delete2.test
  delete3.test delete.test descidx1.test descidx2.test descidx3.test
  distinctagg.test distinct.test e_createtable.test e_delete.test
  e_droptrigger.test e_dropview.test e_expr.test e_insert.test
  eqp.test e_reindex.test e_resolve.test e_select2.test e_select.test
  e_update.test exists.test expr.test fkey1.test fkey2.test fkey3.test
  fkey4.test fkey5.test func2.test func3.test func.test 
  in3.test in4.test in5.test index2.test index3.test
  index4.test index5.test indexedby.test index.test
  insert2.test insert3.test insert4.test insert5.test insert.test
  instr.test in.test intpkey.test join2.test join3.test join4.test
  join5.test join6.test join.test like2.test like.test limit.test
  minmax2.test minmax3.test minmax4.test minmax.test misc1.test misc2.test
  misc3.test misc4.test misc5.test misc6.test misc7.test orderby1.test
  orderby2.test orderby3.test orderby4.test randexpr1.test regexp1.test
  reindex.test rowhash.test rowid.test schema2.test schema3.test
  schema4.test schema5.test schema.test
  select1.test select2.test select3.test select4.test select5.test
  select6.test select7.test select8.test select9.test selectA.test
  selectB.test selectC.test selectD.test selectE.test sidedelete.test
  sort.test spellfix.test subquery2.test subquery.test subselect.test
  substr.test tkt-02a8e81d44.test tkt1435.test tkt1443.test tkt1444.test
  tkt1449.test tkt1473.test tkt1501.test tkt1512.test tkt1514.test
  tkt1536.test tkt1537.test tkt1567.test tkt1644.test tkt1667.test
  tkt1873.test tkt2141.test tkt2192.test tkt2213.test tkt2251.test
  tkt2285.test tkt2332.test tkt2339.test tkt2391.test tkt2409.test
  tkt2450.test tkt2565.test tkt2640.test tkt2643.test tkt2686.test
  tkt-26ff0c2d1e.test tkt2767.test tkt2817.test tkt2820.test tkt2822.test
  tkt2832.test tkt2854.test tkt2920.test tkt2927.test tkt2942.test
  tkt-2a5629202f.test tkt-2d1a5c67d.test tkt-2ea2425d34.test tkt3080.test
  tkt3093.test tkt3121.test tkt-31338dca7e.test tkt-313723c356.test
  tkt3201.test tkt3292.test tkt3298.test tkt3334.test tkt3346.test
  tkt3357.test tkt3419.test tkt3424.test tkt3442.test tkt3457.test
  tkt3461.test tkt3493.test tkt3508.test tkt3522.test tkt3527.test
  tkt3541.test tkt3554.test tkt3581.test tkt35xx.test tkt3630.test
  tkt3718.test tkt3731.test tkt3757.test tkt3761.test tkt3762.test
  tkt3773.test tkt3791.test tkt3793.test tkt3810.test tkt3824.test
  tkt3832.test tkt3838.test tkt3841.test tkt-385a5b56b9.test tkt3871.test
  tkt3879.test tkt-38cb5df375.test tkt3911.test tkt3918.test tkt3922.test
  tkt3929.test tkt3935.test tkt3992.test tkt3997.test tkt-3998683a16.test
  tkt-3a77c9714e.test tkt-3fe897352e.test tkt4018.test tkt-4a03edc4c8.test
  tkt-4dd95f6943.test tkt-54844eea3f.test tkt-5d863f876e.test
  tkt-5e10420e8d.test tkt-5ee23731f.test tkt-6bfb98dfc0.test
  tkt-752e1646fc.test tkt-78e04e52ea.test tkt-7a31705a7e6.test
  tkt-7bbfb7d442.test tkt-80ba201079.test tkt-80e031a00f.test
  tkt-8454a207b9.test tkt-91e2e8ba6f.test tkt-94c04eaadb.test
  tkt-9d68c883.test tkt-a7b7803e.test tkt-b1d3a2e531.test
  tkt-b351d95f9.test tkt-b72787b1.test tkt-bd484a090c.test
  tkt-bdc6bbbb38.test tkt-c48d99d690.test tkt-cbd054fa6b.test
  tkt-d11f09d36e.test tkt-d635236375.test tkt-d82e3f3721.test
  tkt-f3e5abed55.test tkt-f777251dc7a.test tkt-f7b4edec.test
  tkt-f973c7ac31.test tkt-fa7bf5ec.test tkt-fc62af4523.test
  tkt-fc7bd6358f.test trigger1.test trigger2.test trigger3.test
  trigger4.test trigger5.test trigger6.test trigger7.test trigger8.test
  trigger9.test triggerA.test triggerB.test triggerC.test triggerD.test
  types2.test types3.test types.test unique.test unordered.test
  update.test view.test vtab1.test vtab2.test vtab3.test vtab4.test
  vtab5.test vtab6.test vtab7.test vtab8.test vtab9.test vtab_alter.test
  vtabA.test vtabB.test vtabC.test vtabD.test vtabE.test
  vtabF.test where2.test where3.test where4.test where5.test where6.test
  where7.test where8m.test where8.test where9.test whereA.test whereB.test
  whereC.test whereD.test whereE.test whereF.test wherelimit.test
  where.test
}

test_suite "vfslog" -prefix "" -description {
  "Vfslog" quick test suite. Like "veryquick" except does not omits
  a few tests that do not work with a version 1 VFS. And the quota* tests,
  which do not work with a VFS that uses the pVfs argument passed to
  sqlite3_vfs methods.
} -files [
  test_set $allquicktests -exclude *malloc* *ioerr* *fault* oserror.test \
  pager1.test syscall.test sysfault.test tkt3457.test quota* superlock* \
  wal* mmap*
]

lappend ::testsuitelist xxx
#-------------------------------------------------------------------------
# Define the coverage related test suites:
#
#   coverage-wal
#
test_suite "coverage-wal" -description {
  Coverage tests for file wal.c.
} -files {
  wal.test       wal2.test     wal3.test       walmode.test    
  walbak.test    walhook.test  walcrash2.test  walcksum.test
  walfault.test  walbig.test   walnoshm.test
  wal5.test
} 

test_suite "coverage-pager" -description {
  Coverage tests for file pager.c.
} -files {
  pager1.test    pager2.test  pagerfault.test  pagerfault2.test
  walfault.test  walbak.test  journal2.test    tkt-9d68c883.test
} 

test_suite "coverage-analyze" -description {
  Coverage tests for file analyze.c.
} -files {
  analyze3.test analyze4.test analyze5.test analyze6.test
  analyze7.test analyze8.test analyze9.test analyzeA.test
  analyze.test analyzeB.test mallocA.test
} 

test_suite "coverage-sorter" -description {
  Coverage tests for file vdbesort.c.
} -files {
  sort.test sortfault.test
} 


lappend ::testsuitelist xxx
#-------------------------------------------------------------------------
# Define the permutation test suites:
#

# Run some tests using pre-allocated page and scratch blocks.
#
# mmap1.test is excluded because a good number of its tests depend on 
# the page-cache being larger than the database. But this permutation
# causes the effective limit on the page-cache to be just 24 pages.
#
test_suite "memsubsys1" -description {
  Tests using pre-allocated page and scratch blocks
} -files [
  test_set $::allquicktests -exclude ioerr5.test malloc5.test mmap1.test
] -initialize {
  catch {db close}
  sqlite3_shutdown
  sqlite3_config_pagecache 4096 24
  sqlite3_config_scratch 25000 1
  sqlite3_initialize
  autoinstall_test_functions
} -shutdown {
  catch {db close}
  sqlite3_shutdown
  sqlite3_config_pagecache 0 0
  sqlite3_config_scratch 0 0
  sqlite3_initialize
  autoinstall_test_functions
}

# Run some tests using pre-allocated page and scratch blocks. This time
# the allocations are too small to use in most cases.
#
# Both ioerr5.test and malloc5.test are excluded because they test the
# sqlite3_soft_heap_limit() and sqlite3_release_memory() functionality.
# This functionality is disabled if a pre-allocated page block is provided.
#
test_suite "memsubsys2" -description {
  Tests using small pre-allocated page and scratch blocks
} -files [
  test_set $::allquicktests -exclude ioerr5.test malloc5.test
] -initialize {
  catch {db close}
  sqlite3_shutdown
  sqlite3_config_pagecache 512 5
  sqlite3_config_scratch 1000 1
  sqlite3_initialize
  autoinstall_test_functions
} -shutdown {
  catch {db close}
  sqlite3_shutdown
  sqlite3_config_pagecache 0 0
  sqlite3_config_scratch 0 0
  sqlite3_initialize
  autoinstall_test_functions
}

# Run all tests with the lookaside allocator disabled.
#
test_suite "nolookaside" -description {
  OOM tests with lookaside disabled
} -initialize {
  catch {db close}
  sqlite3_shutdown
  sqlite3_config_lookaside 0 0
  sqlite3_initialize
  autoinstall_test_functions
} -shutdown {
  catch {db close}
  sqlite3_shutdown
  sqlite3_config_lookaside 100 500
  sqlite3_initialize
  autoinstall_test_functions
} -files $::allquicktests

# Run some tests in SQLITE_CONFIG_SINGLETHREAD mode.
#
test_suite "singlethread" -description {
  Tests run in SQLITE_CONFIG_SINGLETHREAD mode
} -initialize {
  catch {db close}
  sqlite3_shutdown
  catch {sqlite3_config singlethread}
  sqlite3_initialize
  autoinstall_test_functions
} -files {
  delete.test   delete2.test  insert.test  rollback.test  select1.test
  select2.test  trans.test    update.test  vacuum.test    types.test
  types2.test   types3.test
} -shutdown {
  catch {db close}
  sqlite3_shutdown
  catch {sqlite3_config serialized}
  sqlite3_initialize
  autoinstall_test_functions
}

test_suite "nomutex" -description {
  Tests run with the SQLITE_OPEN_MULTITHREADED flag passed to sqlite3_open().
} -initialize {
  rename sqlite3 sqlite3_nomutex
  proc sqlite3 {args} {
    if {[string range [lindex $args 0] 0 0] ne "-"} {
      lappend args -fullmutex 0 -nomutex 1
    }
    uplevel [concat sqlite3_nomutex $args]
  }
} -files {
  delete.test   delete2.test  insert.test  rollback.test  select1.test
  select2.test  trans.test    update.test  vacuum.test    types.test
  types2.test   types3.test
} -shutdown {
  rename sqlite3 {}
  rename sqlite3_nomutex sqlite3
}

# Run some tests in SQLITE_CONFIG_MULTITHREAD mode.
#
test_suite "multithread" -description {
  Tests run in SQLITE_CONFIG_MULTITHREAD mode
} -initialize {
  catch {db close}
  sqlite3_shutdown
  catch {sqlite3_config multithread}
  sqlite3_initialize
  autoinstall_test_functions
} -files {
  delete.test   delete2.test  insert.test  rollback.test  select1.test
  select2.test  trans.test    update.test  vacuum.test    types.test
  types2.test   types3.test   sort4.test
} -shutdown {
  catch {db close}
  sqlite3_shutdown
  catch {sqlite3_config serialized}
  sqlite3_initialize
  autoinstall_test_functions
}

# Run some tests in SQLITE_OPEN_FULLMUTEX mode.
#
test_suite "fullmutex" -description {
  Tests run in SQLITE_OPEN_FULLMUTEX mode
} -initialize {
  rename sqlite3 sqlite3_fullmutex
  proc sqlite3 {args} {
    if {[string range [lindex $args 0] 0 0] ne "-"} {
      lappend args -nomutex 0 -fullmutex 1
    }
    uplevel [concat sqlite3_fullmutex $args]
  }
} -files {
  delete.test   delete2.test  insert.test  rollback.test  select1.test
  select2.test  trans.test    update.test  vacuum.test    types.test
  types2.test   types3.test
} -shutdown {
  rename sqlite3 {}
  rename sqlite3_fullmutex sqlite3
}

# Run some tests using the "onefile" demo.
#
test_suite "onefile" -description {
  Run some tests using the "test_onefile.c" demo
} -initialize {
  rename sqlite3 sqlite3_onefile
  proc sqlite3 {args} {
    if {[string range [lindex $args 0] 0 0] ne "-"} {
      lappend args -vfs fs
    }
    uplevel [concat sqlite3_onefile $args]
  }
} -files {
  conflict.test  insert.test   insert2.test  insert3.test
  rollback.test  select1.test  select2.test  select3.test
} -shutdown {
  rename sqlite3 {}
  rename sqlite3_onefile sqlite3
}

# Run some tests using UTF-16 databases.
#
test_suite "utf16" -description {
  Run tests using UTF-16 databases
} -presql {
  pragma encoding = 'UTF-16'
} -files {
    alter.test alter3.test
    analyze.test analyze3.test analyze4.test analyze5.test analyze6.test
    analyze7.test analyze8.test analyze9.test analyzeA.test analyzeB.test
    auth.test bind.test blob.test capi2.test capi3.test collate1.test
    collate2.test collate3.test collate4.test collate5.test collate6.test
    conflict.test date.test delete.test expr.test fkey1.test func.test
    hook.test index.test insert2.test insert.test interrupt.test in.test
    intpkey.test ioerr.test join2.test join.test lastinsert.test
    laststmtchanges.test limit.test lock2.test lock.test main.test 
    memdb.test minmax.test misc1.test misc2.test misc3.test notnull.test
    null.test progress.test quote.test rowid.test select1.test select2.test
    select3.test select4.test select5.test select6.test sort.test 
    subselect.test tableapi.test table.test temptable.test
    trace.test trigger1.test trigger2.test trigger3.test
    trigger4.test types2.test types.test unique.test update.test
    vacuum.test view.test where.test
}

# Run some tests in exclusive locking mode.
#
test_suite "exclusive" -description {
  Run tests in exclusive locking mode.
} -presql {
  pragma locking_mode = 'exclusive'
} -files {
  rollback.test select1.test select2.test 
  malloc.test ioerr.test
} 

# Run some tests in exclusive locking mode with truncated journals.
#
test_suite "exclusive-truncate" -description {
  Run tests in exclusive locking mode and truncate journal mode.
} -presql {
  pragma locking_mode = 'exclusive';
  pragma journal_mode = TRUNCATE;
} -files {
  delete.test delete2.test insert.test rollback.test select1.test
  select2.test update.test malloc.test ioerr.test
} 

# Run some tests in persistent journal mode.
#
test_suite "persistent_journal" -description {
  Run tests in persistent-journal mode.
} -presql {
  pragma journal_mode = persist
} -files {
  delete.test delete2.test insert.test rollback.test select1.test
  select2.test trans.test update.test vacuum.test 
}

# Run some tests in truncating journal mode.
#
test_suite "truncate_journal" -description {
  Run tests in persistent-journal mode.
} -presql {
  pragma journal_mode = truncate
} -files {
  delete.test delete2.test insert.test rollback.test select1.test
  select2.test trans.test update.test vacuum.test 
  malloc.test ioerr.test
}

# Run some error tests in persistent journal mode.
#
test_suite "persistent_journal_error" -description {
  Run malloc.test and ioerr.test in persistent-journal mode.
} -presql {
  pragma journal_mode = persist
} -files {
  malloc.test ioerr.test
}

# Run some tests in no journal mode.
#
test_suite "no_journal" -description {
  Run tests in no-journal mode.
} -presql {
  pragma journal_mode = persist
} -files {
  delete.test delete2.test insert.test rollback.test select1.test
  select2.test trans.test update.test vacuum.test 
}

# Run some error tests in no journal mode.
#
test_suite "no_journal_error" -description {
  Run malloc.test and ioerr.test in no-journal mode.
} -presql {
  pragma journal_mode = persist
} -files {
  malloc.test ioerr.test
}

# Run some crash-tests in autovacuum mode.
#
test_suite "autovacuum_crash" -description {
  Run crash.test in autovacuum mode.
} -presql {
  pragma auto_vacuum = 1
} -files crash.test

# Run some ioerr-tests in autovacuum mode.
#
test_suite "autovacuum_ioerr" -description {
  Run ioerr.test in autovacuum mode.
} -presql {
  pragma auto_vacuum = 1
} -files ioerr.test

# Run tests with an in-memory journal.
#
test_suite "inmemory_journal" -description {
  Run tests with an in-memory journal file.
} -presql {
  pragma journal_mode = 'memory'
} -files [test_set $::allquicktests -exclude {
  # Exclude all tests that simulate IO errors.
  autovacuum_ioerr2.test incrvacuum_ioerr.test ioerr.test
  ioerr.test ioerr2.test ioerr3.test ioerr4.test ioerr5.test
  vacuum3.test incrblob_err.test diskfull.test backup_ioerr.test
  e_fts3.test fts3cov.test fts3malloc.test fts3rnd.test
  fts3snippet.test mmapfault.test

  # Exclude test scripts that use tcl IO to access journal files or count
  # the number of fsync() calls.
  pager.test exclusive.test jrnlmode.test sync.test misc1.test 
  journal1.test conflict.test crash8.test tkt3457.test io.test
  journal3.test 8_3_names.test

  pager1.test async4.test corrupt.test filefmt.test pager2.test
  corrupt5.test corruptA.test pageropt.test

  # Exclude stmt.test, which expects sub-journals to use temporary files.
  stmt.test

  zerodamage.test

  # WAL mode is different.
  wal* tkt-2d1a5c67d.test backcompat.test e_wal*
}]

ifcapable mem3 {
  test_suite "memsys3" -description {
    Run tests using the allocator in mem3.c.
  } -files [test_set $::allquicktests -exclude {
    autovacuum.test           delete3.test              manydb.test
    bigrow.test               incrblob2.test            memdb.test
    bitvec.test               index2.test               memsubsys1.test
    capi3c.test               ioerr.test                memsubsys2.test
    capi3.test                join3.test                pagesize.test
    collate5.test             limit.test                backup_ioerr.test
    backup_malloc.test
  }] -initialize {
    catch {db close}
    sqlite3_reset_auto_extension
    sqlite3_shutdown
    sqlite3_config_heap 25000000 0
    sqlite3_config_lookaside 0 0
    ifcapable mem5 {
      # If both memsys3 and memsys5 are enabled in the build, the call to
      # [sqlite3_config_heap] will initialize the system to use memsys5.
      # The following overrides this preference and installs the memsys3
      # allocator.
      sqlite3_install_memsys3
    }
    install_malloc_faultsim 1 
    sqlite3_initialize
    autoinstall_test_functions
  } -shutdown {
    catch {db close}
    sqlite3_shutdown
    sqlite3_config_heap 0 0
    sqlite3_config_lookaside 100 500
    install_malloc_faultsim 1 
    sqlite3_initialize
    autoinstall_test_functions
  }
}

ifcapable mem5 {
  test_suite "memsys5" -description {
    Run tests using the allocator in mem5.c.
  } -files [test_set $::allquicktests -exclude {
    autovacuum.test           delete3.test              manydb.test
    bigrow.test               incrblob2.test            memdb.test
    bitvec.test               index2.test               memsubsys1.test
    capi3c.test               ioerr.test                memsubsys2.test
    capi3.test                join3.test                pagesize.test
    collate5.test             limit.test                zeroblob.test
  }] -initialize {
    catch {db close}
    sqlite3_shutdown
    sqlite3_config_heap 25000000 64
    sqlite3_config_lookaside 0 0
    install_malloc_faultsim 1 
    sqlite3_initialize
    autoinstall_test_functions
  } -shutdown {
    catch {db close}
    sqlite3_shutdown
    sqlite3_config_heap 0 0
    sqlite3_config_lookaside 100 500
    install_malloc_faultsim 1 
    sqlite3_initialize
    autoinstall_test_functions
  }

  test_suite "memsys5-2" -description {
    Run tests using the allocator in mem5.c in a different configuration.
  } -files {
    select1.test 
  } -initialize {
    catch {db close}
    sqlite3_shutdown
    sqlite3_config_memstatus 0
    sqlite3_config_heap 40000000 16
    sqlite3_config_lookaside 0 0
    install_malloc_faultsim 1 
    sqlite3_initialize
    autoinstall_test_functions
  } -shutdown {
    catch {db close}
    sqlite3_shutdown
    sqlite3_config_heap 0 0
    sqlite3_config_lookaside 100 500
    install_malloc_faultsim 1 
    sqlite3_initialize
    autoinstall_test_functions
  }
}

ifcapable threadsafe {
  test_suite "no_mutex_try" -description {
     The sqlite3_mutex_try() interface always fails
  } -files [
    test_set $::allquicktests -exclude mutex1.test mutex2.test
  ] -initialize {
    catch {db close}
    sqlite3_shutdown
    install_mutex_counters 1
    set ::disable_mutex_try 1
    sqlite3_initialize
    autoinstall_test_functions
  } -shutdown {
    catch {db close}
    sqlite3_shutdown
    install_mutex_counters 0
    sqlite3_initialize
    autoinstall_test_functions
  }
}

# run_tests "crash_safe_append" -description {
#   Run crash.test with persistent journals on a SAFE_APPEND file-system.
# } -initialize {
#   rename crashsql sa_crashsql
#   proc crashsql {args} {
#     set options [lrange $args 0 [expr {[llength $args]-2}]]
#     lappend options -char safe_append
#     set sql [lindex $args end]
#     lappend options "
#       PRAGMA journal_mode=persistent;
#       $sql
#     "
#     set fd [open test.db-journal w]
#     puts $fd [string repeat 1234567890 100000]
#     close $fd
#     eval sa_crashsql $options
#   }
# } -shutdown {
#   rename crashsql {}
#   rename sa_crashsql crashsql
# } -files crash.test

test_suite "safe_append" -description {
  Run some tests on a SAFE_APPEND file-system.
} -initialize {
  rename sqlite3 sqlite3_safeappend
  proc sqlite3 {args} {
    if {[string range [lindex $args 0] 0 0] ne "-"} {
      lappend args -vfs devsym
    }
    uplevel [concat sqlite3_safeappend $args]
  }
  sqlite3_simulate_device -char safe_append
} -shutdown {
  rename sqlite3 {}
  rename sqlite3_shutdown sqlite3
} -files [
  test_set $::allquicktests shared_err.test -exclude async3.test
]

# The set of tests to run on the alternative-pcache
set perm-alt-pcache-testset {
  async.test
  attach.test
  delete.test delete2.test
  index.test
  insert.test insert2.test
  join.test join2.test
  rollback.test
  select1.test select2.test
  trans.test
  update.test
}

foreach discard_rate {0 10 50 90 100} {
  test_suite "pcache${discard_rate}" -description "
    Alternative pcache implementation with ${discard_rate}% random discard
  " -initialize "
    catch {db close}
    sqlite3_shutdown
    sqlite3_config_alt_pcache 1 $discard_rate 1
    sqlite3_initialize
    autoinstall_test_functions
  " -shutdown {
    catch {db close}
    sqlite3_shutdown
    sqlite3_config_alt_pcache 0 0 0
    sqlite3_config_lookaside 100 500
    install_malloc_faultsim 1 
    sqlite3_initialize
    autoinstall_test_functions
  } -files ${perm-alt-pcache-testset}
}

test_suite "journaltest" -description {
  Check that pages are synced before being written (test_journal.c).
} -initialize {
  catch {db close}
  register_jt_vfs -default ""
} -shutdown {
  unregister_jt_vfs
} -files [test_set $::allquicktests -exclude {
  wal* incrvacuum.test ioerr.test corrupt4.test io.test crash8.test 
  async4.test bigfile.test backcompat.test
}]

if {[info commands register_demovfs] != ""} {
  test_suite "demovfs" -description {
    Check that the demovfs (code in test_demovfs.c) more or less works.
  } -initialize {
    register_demovfs
  } -shutdown {
    unregister_demovfs
  } -files {
    insert.test   insert2.test  insert3.test rollback.test 
    select1.test  select2.test  select3.test
  }
}

test_suite "wal" -description {
  Run tests with journal_mode=WAL
} -initialize {
  set ::G(savepoint6_iterations) 100
} -shutdown {
  unset -nocomplain ::G(savepoint6_iterations)
} -files {
  savepoint.test     savepoint2.test     savepoint6.test
  trans.test         avtrans.test

  fts3aa.test  fts3ab.test  fts3ac.test  fts3ad.test
  fts3ae.test  fts3af.test  fts3ag.test  fts3ah.test
  fts3ai.test  fts3aj.test  fts3ak.test  fts3al.test
  fts3am.test  fts3an.test  fts3ao.test  fts3b.test
  fts3c.test   fts3d.test   fts3e.test   fts3query.test 
}

test_suite "rtree" -description {
  All R-tree related tests. Provides coverage of source file rtree.c.
} -files [glob -nocomplain $::testdir/../ext/rtree/*.test]

test_suite "no_optimization" -description {
  Run test scripts with optimizations disabled using the
  sqlite3_test_control(SQLITE_TESTCTRL_OPTIMIZATIONS) interface.
} -files {
  where.test where2.test where3.test where4.test where5.test
  where6.test where7.test where8.test where9.test
  whereA.test whereB.test wherelimit.test
  select1.test select2.test select3.test select4.test select5.test
  select7.test select8.test selectA.test selectC.test
} -dbconfig {
  optimization_control $::dbhandle all 0
}

test_suite "prepare" -description {
  Run tests with the db connection using sqlite3_prepare() instead of _v2().
} -dbconfig {
  db_use_legacy_prepare $::dbhandle 1
  #$::dbhandle cache size 0
} -files [
  test_set $allquicktests -exclude *malloc* *ioerr* *fault*
]

# End of tests
#############################################################################

# run_tests NAME OPTIONS
#
# where available options are:  
#
#       -description TITLE
#       -initialize  SCRIPT
#       -shutdown    SCRIPT
#       -presql      SQL
#       -files       LIST-OF-FILES
#       -prefix      NAME
#
proc run_tests {name args} {
  array set options $args

  set ::G(perm:name)         $name
  set ::G(perm:prefix)       $options(-prefix)
  set ::G(perm:presql)       $options(-presql)
  set ::G(isquick)           1
  set ::G(perm:dbconfig)     $options(-dbconfig)

  uplevel $options(-initialize)

  foreach file [lsort $options(-files)] {
    if {[file tail $file] == $file} { set file [file join $::testdir $file] }
    slave_test_file $file
  }

  uplevel $options(-shutdown)

  unset ::G(perm:name)
  unset ::G(perm:prefix)
  unset ::G(perm:presql)
  unset ::G(perm:dbconfig)
}

proc run_test_suite {name} {
  if {[info exists ::testspec($name)]==0} {
    error "No such test suite: $name"
  }
  uplevel run_tests $name $::testspec($name)
}

proc help {} {
  puts "Usage: $::argv0 TESTSUITE ?TESTFILE?"
  puts ""
  puts "Available test-suites are:"
  foreach k $::testsuitelist {
    if {[info exists ::testspec($k)]==0} {
      puts "         ----------------------------------------"
      puts ""
    } else {
      array set o $::testspec($k)
      puts "Test suite: \"$k\""
      set d [string trim $o(-description)]
      set d [regsub {\n *} $d "\n  "]
      puts "  $d"
      puts ""
    }
  }
  exit -1
}

if {[info script] == $argv0} {
  proc main {argv} {
    if {[llength $argv]==0} {
      help
    } else {
      set suite [lindex $argv 0]
      if {[info exists ::testspec($suite)]==0} help
      set extra ""
      if {[llength $argv]>1} { set extra [list -files [lrange $argv 1 end]] }
      eval run_tests $suite $::testspec($suite) $extra
    }
  }
  main $argv
  finish_test
}
