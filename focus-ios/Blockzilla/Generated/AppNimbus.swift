// This file was autogenerated by the `nimbus-fml` crate.
// Trust me, you don't want to mess with it!
#if canImport(FocusAppServices)
    import FocusAppServices
#endif
#if canImport(Foundation)
    import Foundation
#endif

///
/// An object for safely accessing feature configuration from Nimbus.
///
/// This is generated.
public class AppNimbus : FeatureManifestInterface {
    public typealias Features = AppNimbusFeatures

    ///
    /// This should be populated at app launch; this method of initializing features
    /// will be removed in favor of the `initialize` function.
    ///
    public var api: FeaturesInterface?

    ///
    /// This method should be called as early in the startup sequence of the app as possible.
    /// This is to connect the Nimbus SDK (and thus server) with the `AppNimbus`
    /// class.
    ///
    /// The lambda MUST be threadsafe in its own right.
    public func initialize(with getSdk: @escaping () -> FeaturesInterface?) {
        self.getSdk = getSdk
        self.features.nimbusValidation.with(sdk: getSdk)
        self.features.onboardingVariables.with(sdk: getSdk)
        self.reinitialize()
    }

    fileprivate lazy var getSdk: GetSdk = { [self] in self.api }

    ///
    /// Represents all the features supported by Nimbus
    ///
    public let features = Features()

    public func getCoenrollingFeatureIds() -> [String] {
        []
    }

    /// Introspection utility method.
    public func getFeature(featureId: String) -> FeatureHolderAny? {
        switch featureId {
            case "nimbus-validation": return FeatureHolderAny(wrapping: features.nimbusValidation)
            case "onboarding-variables": return FeatureHolderAny(wrapping: features.onboardingVariables)
            default: return nil
        }
    }

    ///
    /// All generated initialization code. Clients shouldn't need to override or call
    /// this.
    /// We put it in a separate method because we have to be quite careful about what order
    /// the initialization happens inâ€” e.g. when importing other FML files.
    ///
    private func reinitialize() {
        // Nothing left to do.
    }

    ///
    /// Refresh the cache of configuration objects.
    ///
    /// For performance reasons, the feature configurations are constructed once then cached.
    /// This method is to clear that cache for all features configured with Nimbus.
    ///
    /// It must be called whenever the Nimbus SDK finishes the `applyPendingExperiments()` method.
    ///
    public func invalidateCachedValues() {
        features.nimbusValidation.with(cachedValue: nil)
        features.onboardingVariables.with(cachedValue: nil)
    }

    ///
    /// A singleton instance of AppNimbus
    ///
    public static let shared = AppNimbus()
}

public class AppNimbusFeatures {
    /// A tiny feature to validate that Nimbus is working
    public lazy var nimbusValidation: FeatureHolder<NimbusValidation> = {
        FeatureHolder(AppNimbus.shared.getSdk, featureId: "nimbus-validation") { variables, prefs in
            NimbusValidation(variables, prefs)
        }
    }()
    /// A collection of variables about onboarding
    public lazy var onboardingVariables: FeatureHolder<OnboardingVariables> = {
        FeatureHolder(AppNimbus.shared.getSdk, featureId: "onboarding-variables") { variables, prefs in
            OnboardingVariables(variables, prefs)
        }
    }()
}

// Public interface members begin here.

/// A tiny feature to validate that Nimbus is working
public class NimbusValidation: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let boldTipTitle: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        boldTipTitle: Bool = true
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            boldTipTitle: boldTipTitle))
    }

    enum CodingKeys: String, CodingKey {
        case boldTipTitle = "bold-tip-title"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(boldTipTitle, forKey: .boldTipTitle)
    }

    /// Make the tips title label bold
    public lazy var boldTipTitle: Bool = {
        self._variables.getBool("bold-tip-title") ?? _defaults.boldTipTitle
    }()
    
}
extension NimbusValidation: FMLFeatureInterface {}
/// A collection of variables about onboarding
public class OnboardingVariables: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let showNewOnboarding: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        showNewOnboarding: Bool = true
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            showNewOnboarding: showNewOnboarding))
    }

    enum CodingKeys: String, CodingKey {
        case showNewOnboarding = "show-new-onboarding"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(showNewOnboarding, forKey: .showNewOnboarding)
    }

    /// Should the v2 of the onboarding be shown.
    public lazy var showNewOnboarding: Bool = {
        self._variables.getBool("show-new-onboarding") ?? _defaults.showNewOnboarding
    }()
    
}
extension OnboardingVariables: FMLFeatureInterface {}

